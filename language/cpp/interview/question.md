# interview

```cpp
// map 遍历删除多个元素

std::unordered_map<uint32_t, uint32_t> objs{ {1,2}, {2,3}, {3,4}, {4,5}, {5,6}, {6,7} };
// 1. wrong
for (auto& [k, v] : objs) {
  if (v % 2 == 0) {
    objs.erase(k);
  }
}

// 2. wrong
auto iter = objs.begin();
while (iter != objs.end()) {  
  if (iter->second % 2 == 0) {
    objs.erase(iter);
  }
  iter++;
  // std::cout << "iter: " << std::distance(objs.begin(), iter) << std::endl;
}

// 3. wrong
for (auto it = objs.begin(); it != objs.end(); ++it) {
  if (it->second % 2 == 0) {
    objs.erase(it);
  }
}

// 4. correct
auto iter = objs.begin();
while (iter != objs.end()) {
  if (iter->second % 2 == 0) {
    objs.erase(iter++);
  } else {
    iter++;
  }
}

```

- 重载覆盖隐藏区别
    - 父类: virtual void func(int a);
    - 子类: virtual void func(int a, int b);
- 类构造函数初始化方式区别，列表初始化，函数体初始化
- 多态写法反过来会怎样， 友元函数是否可以为virtual
- 虚函数是否可以为内联函数
- placement new
- RTTI
- 头文件防止重复include方式：宏定义和pragma once区别
- STL
    - vector的push_back和emplace_back区别
        - 左值用push_back,右值用emplace_back,局部变量使用emplace_back,不需要先构建再拷贝或者移动
    - vector在clear元素后是否会真正清除内存？如何清除（shrink_to_fit）
    - unordered_set性能如何排查
        - 查看每个桶的大小（什么时候进行扩充）。load_factor返回每个桶的平均元素数量
    - tuple是如何实现的
        - 递归继承
- C++11：
    - lambda函数，捕获方式有哪些
        - 1、空。没有使用任何函数对象参数。
            
            2、=。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。
            
            3、&。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。
            
            4、this。函数体内可以使用Lambda所在类中的成员变量。
            
            5、a。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。
            
            6、&a。将a按引用进行传递。
            
            7、a, &b。将a按值进行传递，b按引用进行传递。
            
            8、=，&a, &b。除a和b按引用进行传递外，其他参数都按值进行传递。
            
            9、&, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。
            [https://blog.csdn.net/zh379835552/article/details/19542181](https://blog.csdn.net/zh379835552/article/details/19542181)
            
    - 智能指针有哪几种，unique和shared区别，unique是否可以作为函数的返回值，weak使用场景
    - auto是否能识别出const
    - move语义，完美转发
    - constexpr


- 对象的创建与生命周期管理（RAII)、左值与右值
- 左值和右值有什么区别？引用是什么？右值引用是什么，用于解决什么问题？
- std::move是什么用处？一个对象转成右值并被其他对象占用内存之后，该对象处于什么状态？后续还能否使用该对象？编译器- 会帮我们做些规避措施吗？
- 是否了解过移动构造和移动赋值函数？具体两者有什么用处？
- 有了解过C++各种类型的变量的生命周期吗？比如说static变量，栈变量，全局变量等
- 
- POD类型、以及bigThree(Five）
- 结构体和类有什么本质区别？（没什么本质区别，只是结构体成员默认公有，而类的成员默认私有）
- 如果写一个空类，编译器会帮忙生成哪些成员？一个空类的对象占用多大空间？为什么空类对象还要占一个字节大小？
- 
- 内存管理，malloc,new,operator new、智能指针等
- malloc/free和new/delete的异同点是什么（前者是函数，只负责分配释放内存；后者是运算符，不仅分配且构造对象，最后- 析构并释放内存）？如何让一个类不能new出来？
- 共享指针（std::shared_ptr）是如何实现的？引用计数存在哪了，什么时候初始化的？（补充问题：能否作为类成员变量？- 类静态变量？为何只能作为指针成员？是否保证线程安全？）
- 弱指针（std::weak_ptr）的意义是什么（解决共享指针循环引用导致的内存泄漏）？为何不直接用原生指针？
- 说一说C++程序运行时候的内存空间模型，主要分为哪几个部分？每个部分的作用是什么？全局数据和静态数据存储在哪段中- （stack栈区，内存映射区，heap堆区，BBS段和DATA段，text段）
- 函数可以返回unique_ptr对象吗？为什么？（可以，unique_ptr支持move操作）
- 如何在指定的内存位置上构建新的对象?(placement new)，一般在什么场景使用？
- 为什么malloc需要指定大小,free不需要指定大小?为什么new创建对象数组不能指定构造函数?
- 如何定义一个只能在堆/栈上生成对象的类?
- new以及delete一个子类实例时，构造函数以及析构函数的调用顺序是怎样的？

### 标准库中的容器数据结构与算法效率
- std::vector和std::list有什么区别？底层数据结构是什么？适用的场景分别是什么？（数组和链表，前者适合随机访问，后者适合插入删除）
- std::list如何快速找到中间元素？时间复杂度是多少？（使用快慢指针，慢的每次移动一步，快的每次移动两步）
- std::map底层数据结构是什么（红黑树）？红黑树是一颗怎样的树（大概说出即可）？红黑树的这些限制或要求的本质原因是什么（促进平衡）？二叉树平衡的意义是什么（加速搜索）？
- std::vector clear 和 erase的区别？
- std::vector resize reserve 的区别是什么？
- std::vector push_back和emplace_back区别,使用场景建议(左值用push_back,右值用emplace_back,局部变量使用emplace_back,不需要先构建再拷贝或者移动)
- std::vector 调用clear或resize(缩小)后内存是否真正被清除?(没有,可以调用shrink_to_fit清除)
- 说一说unordered_map和map的实现机制,性能差异


### pass
- 基于虚函数的多态，以及有继承层次的对象的内存布局
- 虚函数是什么？为什么需要虚函数？为何不直接在父类和子类中定义相同的函数，而非得加virtual关键字？虚函数具体怎么使用？表述一个使用场景。
- 虚函数的实现原理是什么？（虚函数表，虚表指针）
- 虚函数表在哪里？有几份？谁分配的？
- 什么样的变量应该在成员初始化列表中进行初始化？在成员列表初始化跟在构造函数中进行赋值初始化有什么区别？
- 有继承关系时,基类析构函数是否一定要加上virtual关键字,不加会有什么问题?(不加可能会内存泄露)
- 虚函数是否可以为内联函数?构造函数是否可以为虚函数?构造函数中是否可以调用虚函数?
- 公有继承，私有继承以及保护继承有什么区别？继承后的子类以及子类实例可以访问哪些成员呢？
- 虚函数和纯虚函数有什么区别？纯虚函数的使用场景是怎样的？

### 多线程：互斥与同步，锁与条件变量，原子，feature与promise
进程线程的区别是什么？线程的优势是什么？多线程可能会遇到什么问题（引出线程同步）？如何做线程同步，C++里有哪些基础设施用于线程同步？
生产者消费者模型是什么？如何减少线程同步带来的性能损失？无锁编程是什么？
线程池是什么？解决了什么问题？适用于什么场景？能描述一个具体的实现方式吗？
流水线机制是什么？解决了什么问题？提升了什么性能？延迟和吞吐量的概念是什么？如何提升流水线的效率（分段均匀）？分段不均匀时会产生什么影响？
std::lock_guard和std::unique_lock的区别是什么？
volatile的作用是什么？能保证变量被互斥的访问吗？
什么是虚假唤醒？怎么防止虚假唤醒？

### 异常与错误处理，异常安全
抛出异常后，后面的代码无法执行了，那异常之前定义的对象该如何析构和释放？异常之前手动分配的内存是否会自动释放？如何保证不内存泄漏？
如果写的一个函数确定不会出现异常，该如何告诉编译器这一点？

### 模板技术：SIFNAE、变长参数的模板、完美转发
有编写过自己的模板类或模板函数吗？模板类或函数为何都在头文件内定义？能否在源文件内定义？（不能，因为模板类和函数还不是真正的类或函数，只有在编译器确定实际类型后才能生成真正的类或函数定义）
在编写模板类或函数时，如何限制模板类型T的数据类型或者其他属性？如何根据模板类型T的实际类型都不同的代码分支？

### 操作系统基础：进程管理与内存管理
进程是什么，和程序有什么关系？一个进程的内存空间包含哪些部分？同一程序启动的两个不同的进程中打印某个变量的内存地址可能是一样的，这怎么理解？
内存管理具体是在做什么管理？为何需要段页式内存管理，主要解决什么问题？
内存池是什么？有了内存管理为何还要内存池？
固态硬盘速度这么快容量还这么大，能做物理内存使用吗？
进程间私有和共享的资源有哪些
私有:  地址空间,堆,全局变量,栈,寄存器
共享:  代码段,公共数据,进程目录,进程ID
线程间私有和共享的资源有哪些
- 私有:  线程栈,寄存器,程序计数器
共享:  堆,地址空间,全部变量,静态变量

### 工具的掌握：CMake、Git、Docker等

- 是否使用过CMake，和make有什么区别？CMake中加入带包含的头文件目录或待链接的库文件目录时用什么语句？构建一个可执行文件用什么语句？构建一个库文件用什么语句？想把一个文件安装到安装目录用什么语句？
- 使用过Git做版本管理吗？常用的命令有哪些？推上去的代码遇到合并冲突怎么办？刚提交的代码有误，需要回退怎么办？
- Git中的分支、提交和标签有什么区别和关系？
- Git中的工作区、暂存区、版本库三者的作用是什么？撤销已经add的修改怎么做？
- 用过rebase操作吗?rebase和merge有什么区别?
- gdb有用过吗？gdb里面怎么看某个变量的值？怎么看当前的调用栈？